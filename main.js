/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VivaldiNotesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// setting.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  // notesPath: 'C:\\Users\\USUARIO\\AppData\\Local\\Vivaldi\\User Data\\Default\\',
  vaultLocation: "/",
  interval: 45e3,
  notesTemplate: "---\nguid: {{VIVALDI_GUID}}\nurl: {{URL}}\ndate_created: {{DATE_CREATED}}\n---\n{{CONTENT}}\n---\n{{IMAGES}}\n\n"
};
var VivaldiNotesSettingtTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Vivaldi Notes Plugin" });
    new import_obsidian.Setting(containerEl).setName("Vivaldi notes path notes path").setDesc("The path where vivaldi store your notes. You can find it entering vivaldi://about/ on your vivaldi browser under the User Profile section.").addText(
      (text) => text.setPlaceholder("C:\\Users\\User\\AppData\\Local\\Vivaldi\\User Data\\Default\\").setValue(this.plugin.settings.notesPath).onChange((value) => {
        this.plugin.settings.notesPath = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("New note path").setDesc("The path where the new notes will be created.").addText(
      (text) => text.setPlaceholder("/").setValue(this.plugin.settings.vaultLocation).onChange((value) => {
        this.plugin.settings.vaultLocation = value;
        this.plugin.saveData(this.plugin.settings);
      })
      // .addSearch((search) => {
      //   search.setPlaceholder('Search for vault location').setDisabled(true);
      // })
    );
    new import_obsidian.Setting(containerEl).setName("Template for new notes").setDesc("The templates of the note that will be created. \n You can use the following variables: {{VIVALDI_GUID}}, {{URL}}, {{DATE_CREATED}}, {{CONTENT}}, {{IMAGES}}. Content is required").addTextArea(
      (text) => {
        text.inputEl.rows = 20;
        text.inputEl.cols = 50;
        return text.setPlaceholder("---\nguid: {{VIVALDI_GUID}}\nurl: {{URL}}\ndate_created:{{DATE_CREATED}}\n---\n{{CONTENT}}\n---\n{{IMAGES}}\n\n").setValue(this.plugin.settings.notesTemplate).onChange((value) => {
          this.plugin.settings.notesTemplate = value;
          this.plugin.saveData(this.plugin.settings);
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Interval for checking new notes").setDesc("The interval in milliseconds for checking new notes").addSlider(
      (number) => number.setDynamicTooltip().setLimits(100, 6e5, 5e3).setValue(this.plugin.settings.interval).onChange((value) => {
        this.plugin.settings.interval = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
    containerEl.createEl("p", { text: "by Arturo David Rebolledo Rosenstiehl from Barranquilla, Colombia", attr: { style: "text-align: center; font-size: 0.8em; color: #888; margin-top: 20px" } });
  }
};

// view.ts
var import_obsidian2 = require("obsidian");

// utils.ts
function getFirstLineWithoutHash(str) {
  const regex = /^(?:#|\r|\n)*[ ]*.*?([^\n]{0,40})/gms;
  if (str == "" || str == null) {
    return "";
  }
  const match = regex.exec(str);
  if (match) {
    let firstLine = match[1].replace(/[\\\/<>:|?"-]/g, "");
    return firstLine.replace(/[.\s]+$/, "");
  }
  return "";
}

// view.ts
var fs = __toESM(require("fs"));

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// view.ts
var VIEW_TYPE = "vivaldi-notes-view";
var VIVALDI_NOTES_PATH_WIN = "C:\\Users\\USUARIO\\AppData\\Local\\Vivaldi\\User Data\\Default\\";
var VivaldiNotesView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // root: Root | null = null;
    // settings:
    this.previousChecksum = "";
    this.fuse = null;
    // All the notes
    this.options = {
      includeScore: true,
      keys: [{ name: "title", weight: 0.6 }, { name: "content", weight: 0.1 }, { name: "id", weight: 0.3 }]
    };
    this.renderedList = null;
    this.intervalId = null;
    this.plugin = plugin;
  }
  // notes = getNotesJSON()
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Vivaldi Notes Viewer";
  }
  getIcon() {
    return "file-check-2";
  }
  async onOpen() {
    console.log("Opened Vivaldi Notes Viewer");
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "Vivaldi Notes" });
    const { notes, checksum: prChecksum } = await this.getNotesJSON(VIVALDI_NOTES_PATH_WIN);
    this.previousChecksum = prChecksum;
    this.appNotes = notes.map((note) => {
      let title = getFirstLineWithoutHash(note.content);
      return { ...note, title };
    });
    this.fuse = new Fuse(this.appNotes, this.options);
    this.filteredNotesList = this.appNotes;
    const searchBar = container.createEl("input", { cls: "search-bar", attr: { type: "search", placeholder: "Search...", enterKeyhint: "search" } });
    this.renderedList = container.createEl("ul", { cls: "vivaldi-notes-list" });
    searchBar.addEventListener("input", (0, import_obsidian2.debounce)((e) => {
      var _a, _b;
      let value = e.target.value;
      if (value != null && value != void 0 && value != "" && this.fuse) {
        let resultado = this.fuse.search(value);
        this.filteredNotesList = resultado.map((note) => note.item);
        while ((_a = this.renderedList) == null ? void 0 : _a.firstChild) {
          (_b = this.renderedList) == null ? void 0 : _b.removeChild(this.renderedList.firstChild);
        }
        if (this.filteredNotesList != null) {
          this.renderNotes(this.filteredNotesList);
        }
      } else if (value == "") {
        this.renderNotes(this.appNotes);
      }
    }, 120));
    this.renderNotes(this.appNotes);
    this.intervalId = this.registerInterval(1);
  }
  onviewwillunload() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  registerInterval(id) {
    const intervalTime = this.plugin.settings.interval;
    return window.setInterval(async () => {
      var _a, _b, _c;
      const currentChecksum = await this.getNotesChecksum(this.plugin.settings.notesPath);
      console.log(currentChecksum);
      if (currentChecksum !== this.previousChecksum) {
        const { notes: newNotesList } = await this.getNotesJSON(this.plugin.settings.notesPath);
        this.appNotes = newNotesList.map((note) => {
          let title = getFirstLineWithoutHash(note.content);
          return { ...note, title };
        });
        this.fuse = new Fuse(this.appNotes, this.options);
        let notesList = this.appNotes;
        while ((_a = this.renderedList) == null ? void 0 : _a.firstChild) {
          (_c = this.renderedList) == null ? void 0 : _c.removeChild((_b = this.renderedList) == null ? void 0 : _b.firstChild);
        }
        await this.renderNotes(notesList);
        this.previousChecksum = currentChecksum;
      }
    }, intervalTime);
  }
  async renderNotes(list) {
    await list.filter((note) => note.type === "note" && note.content).forEach((note) => {
      var _a, _b;
      (_a = this.renderedList) == null ? void 0 : _a.createEl("li", { text: note.title.length == 40 ? note.title + "..." : note.title, cls: "vivaldi-notes-list-item", attr: { id: note.id } }).onClickEvent(async (event) => {
        if (!this.verifyCreatedNotes(note.title)) {
          (0, import_obsidian2.setIcon)(event.target.createDiv({ cls: "check-icon" }), "file-check-2");
          new import_obsidian2.Notice("Note imported");
          this.createNewNote(note.title, note);
        } else {
          new import_obsidian2.Notice("Note already imported");
          this.app.workspace.openLinkText(note.title, "", false);
        }
      });
      if (this.verifyCreatedNotes(note.title)) {
        (0, import_obsidian2.setIcon)(((_b = this.renderedList) == null ? void 0 : _b.lastElementChild).createDiv({ cls: "check-icon" }), "file-check-2");
      }
    });
  }
  async getNotesJSON(path) {
    let stringpath = (0, import_obsidian2.normalizePath)(path + "/Notes");
    const fileContents = await fs.readFileSync(stringpath, "utf8");
    let dato = JSON.parse(fileContents);
    return { notes: dato.children, checksum: dato.checksum };
  }
  async getNotesChecksum(path) {
    let stringpath = (0, import_obsidian2.normalizePath)(path + "/Notes");
    const fileContents = await fs.readFileSync(stringpath);
    const checksum = fileContents.slice(19, 51).toString();
    return checksum;
  }
  async createNewNote(title, note) {
    let content = this.plugin.settings.notesTemplate.replace("{{VIVALDI_GUID}}", note.guid ? note.guid : "").replace("{{VIVALDI_ID}}", note.id ? note.id.toString() : "").replace("{{URL}}", note.url ? note.url : "").replace("{{DATE_CREATED}}", note.date_added ? new Date((note.date_added - 116444736e8) / 1e3).toISOString() : "").replace("{{CONTENT}}", note.content ? note.content : "");
    if (note.children.length > 0) {
      let imageArray = note.children.filter((child) => child.type === "attachment").map((child) => `
<img src="${(0, import_obsidian2.normalizePath)(this.plugin.settings.notesPath + "/SyncedFiles/" + child.content)}" width="100%" height="auto"/>
`);
      content = content.replace("{{IMAGES}}", imageArray.toString());
    } else {
      content = content.replace("{{IMAGES}}", "");
    }
    let carpeta = this.plugin.settings.vaultLocation + "/";
    console.log(carpeta);
    const stringpath = (0, import_obsidian2.normalizePath)(carpeta + title + ".md");
    console.log(stringpath);
    const newNote = await this.app.vault.create(stringpath, content);
    await this.app.workspace.openLinkText(newNote.path, "", true);
    return newNote;
  }
  async getNoteFile(notePath) {
    const file = this.app.vault.getAbstractFileByPath(notePath);
    if (!file || !(file instanceof import_obsidian2.TFile)) {
      throw new Error(`File not found: ${notePath}`);
    }
    return file;
  }
  async getNotesMetadata(notePathORContentString) {
    let file;
    if (typeof notePathORContentString == "string") {
      file = await this.app.vault.read(await this.getNoteFile(notePathORContentString));
    } else {
      file = await this.app.vault.read(notePathORContentString);
    }
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const match = file.match(frontmatterRegex);
    if (!match) {
      return false;
    }
    const frontmatter = (0, import_obsidian2.parseYaml)(match[1]);
    return frontmatter;
  }
  verifyCreatedNotes(title) {
    let carpeta = this.plugin.settings.vaultLocation + "/";
    console.log(carpeta);
    const stringpath = (0, import_obsidian2.normalizePath)(carpeta + title + ".md");
    const noteExists = this.app.vault.getAbstractFileByPath(stringpath) !== null;
    return noteExists;
  }
  async onClose() {
    console.log("Closed Vivaldi Notes Viewer, stopped interval");
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
};

// main.ts
var VivaldiNotesPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new VivaldiNotesSettingtTab(this.app, this));
    this.registerView(VIEW_TYPE, (leaf) => new VivaldiNotesView(leaf, this));
    this.addCommand({
      id: "show-vivaldi-notes",
      name: "Show Vivaldi Notes",
      callback: () => {
        this.app.workspace.getRightLeaf(false).setViewState({
          type: VIEW_TYPE,
          state: "sa",
          pinned: true
        });
      }
    });
    this.registerInterval(
      window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3)
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]
    );
  }
  // async createNewNote(title: string, content: string, url?: string)  {
  //   const newNote = await this.app.vault.create(this.settings.vaultLocation+title, content);
  //   // await this.app.vault.modify(newNote, content);
  //   return newNote;
  // }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzZXR0aW5nLnRzIiwgInZpZXcudHMiLCAidXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL2Z1c2UuanMvZGlzdC9mdXNlLm1qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHtcclxuICBQbHVnaW4sXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIFZpdmFsZGlOb3Rlc1NldHRpbmcsIFZpdmFsZGlOb3Rlc1NldHRpbmd0VGFiIH0gZnJvbSBcInNldHRpbmdcIjtcclxuaW1wb3J0IHsgVklFV19UWVBFLCBWaXZhbGRpTm90ZXNWaWV3IH0gZnJvbSBcIi4vdmlld1wiO1xyXG5cclxuLy8gUmVtZW1iZXIgdG8gcmVuYW1lIHRoZXNlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMhXHJcblxyXG4vLyBpbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XHJcbi8vICAgbXlTZXR0aW5nOiBzdHJpbmc7XHJcbi8vIH1cclxuXHJcbi8vIGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XHJcbi8vICAgbXlTZXR0aW5nOiBcImRlZmF1bHRcIixcclxuLy8gfTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpdmFsZGlOb3Rlc1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcbiAgc2V0dGluZ3M6IFZpdmFsZGlOb3Rlc1NldHRpbmc7XHJcblxyXG4gIGFzeW5jIG9ubG9hZCgpIHtcclxuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcbiAgICBcclxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgVml2YWxkaU5vdGVzU2V0dGluZ3RUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyVmlldyhWSUVXX1RZUEUsIGxlYWYgPT4gbmV3IFZpdmFsZGlOb3Rlc1ZpZXcobGVhZiwgdGhpcykpO1xyXG5cclxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgIGlkOiBcInNob3ctdml2YWxkaS1ub3Rlc1wiLFxyXG4gICAgICBuYW1lOiBcIlNob3cgVml2YWxkaSBOb3Rlc1wiLFxyXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpLnNldFZpZXdTdGF0ZSh7XHJcbiAgICAgICAgICB0eXBlOiBWSUVXX1RZUEUsXHJcbiAgICAgICAgICBzdGF0ZTogXCJzYVwiLFxyXG4gICAgICAgICAgcGlubmVkOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV2hlbiByZWdpc3RlcmluZyBpbnRlcnZhbHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFyIHRoZSBpbnRlcnZhbCB3aGVuIHRoZSBwbHVnaW4gaXMgZGlzYWJsZWQuXHJcbiAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwoXHJcbiAgICAgIHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiBjb25zb2xlLmxvZyhcInNldEludGVydmFsXCIpLCA1ICogNjAgKiAxMDAwKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIG9udW5sb2FkKCkge1xyXG4gICAgLy8gLy8gV2hlbiB1bmxvYWRpbmcsIHdlIG5lZWQgdG8gbWFudWFsbHkgcmVtb3ZlIHRoZSB2aWV3IGZyb20gdGhlIHdvcmtzcGFjZS5cclxuICAgIC8vIFRoZSBPYnNpZGlhbiBwbHVnaW4gc2F5cyBcIkRvbnQgZGV0YWNoIGxlYXZlcyBpbiBvbnVubG9hZFwiIFxyXG4gICAgLy8gdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShWSUVXX1RZUEUpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XHJcbiAgICBcclxuICB9XHJcblxyXG4gIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcbiAgfVxyXG4gIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcclxuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5kZXRhY2hMZWF2ZXNPZlR5cGUoVklFV19UWVBFKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKS5zZXRWaWV3U3RhdGUoe1xyXG4gICAgICB0eXBlOiBWSUVXX1RZUEUsXHJcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcclxuICAgIH0pXHJcbiAgICBcclxuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKFxyXG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSlbMF1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBhc3luYyBjcmVhdGVOZXdOb3RlKHRpdGxlOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgdXJsPzogc3RyaW5nKSAge1xyXG4gIC8vICAgY29uc3QgbmV3Tm90ZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZSh0aGlzLnNldHRpbmdzLnZhdWx0TG9jYXRpb24rdGl0bGUsIGNvbnRlbnQpO1xyXG4gIC8vICAgLy8gYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KG5ld05vdGUsIGNvbnRlbnQpO1xyXG4gIC8vICAgcmV0dXJuIG5ld05vdGU7XHJcbiAgLy8gfVxyXG59XHJcblxyXG4vLyBjbGFzcyBTYW1wbGVNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuLy8gICBjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG4vLyAgICAgc3VwZXIoYXBwKTtcclxuLy8gICB9XHJcblxyXG4vLyAgIG9uT3BlbigpIHtcclxuLy8gICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4vLyAgICAgY29udGVudEVsLnNldFRleHQoXCJXb2FoIVwiKTtcclxuLy8gICB9XHJcblxyXG4vLyAgIG9uQ2xvc2UoKSB7XHJcbi8vICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuLy8gICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xyXG4vLyAgIH1cclxuLy8gfVxyXG5cclxuLy8gY2xhc3MgTXlWaWV3IGV4dGVuZHMgTWFya2Rvd25WaWV3IHtcclxuLy8gICBnZXRWaWV3VHlwZSgpOiBzdHJpbmcge1xyXG4vLyAgICAgcmV0dXJuIFwibXktcGx1Z2luXCI7XHJcbi8vICAgfVxyXG4vLyB9XHJcblxyXG4vLyBjbGFzcyBTYW1wbGVTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbi8vICAgcGx1Z2luOiBNeVBsdWdpbjtcclxuXHJcbi8vICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXlQbHVnaW4pIHtcclxuLy8gICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuLy8gICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4vLyAgIH1cclxuXHJcbi8vICAgZGlzcGxheSgpOiB2b2lkIHtcclxuLy8gICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblxyXG4vLyAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbi8vICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuLy8gICAgICAgLnNldE5hbWUoXCJTZXR0aW5nICMxXCIpXHJcbi8vICAgICAgIC5zZXREZXNjKFwiSXQncyBhIHNlY3JldFwiKVxyXG4vLyAgICAgICAuYWRkVGV4dCh0ZXh0ID0+XHJcbi8vICAgICAgICAgdGV4dFxyXG4vLyAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgeW91ciBzZWNyZXRcIilcclxuLy8gICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcpXHJcbi8vICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgdmFsdWUgPT4ge1xyXG4vLyAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcclxuLy8gICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbi8vICAgICAgICAgICB9KVxyXG4vLyAgICAgICApO1xyXG4vLyAgIH1cclxuLy8gfVxyXG4iLCAiaW1wb3J0IFZpdmFsZGlOb3Rlc1BsdWdpbiBmcm9tICdtYWluJztcclxuaW1wb3J0IHsgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWaXZhbGRpTm90ZXNTZXR0aW5nIHtcclxuICBub3Rlc1BhdGg6IHN0cmluZztcclxuICB2YXVsdExvY2F0aW9uOiBzdHJpbmc7XHJcbiAgbm90ZXNUZW1wbGF0ZTogc3RyaW5nO1xyXG4gIGludGVydmFsOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQYXJ0aWFsPFZpdmFsZGlOb3Rlc1NldHRpbmc+ID0ge1xyXG4gIC8vIG5vdGVzUGF0aDogJ0M6XFxcXFVzZXJzXFxcXFVTVUFSSU9cXFxcQXBwRGF0YVxcXFxMb2NhbFxcXFxWaXZhbGRpXFxcXFVzZXIgRGF0YVxcXFxEZWZhdWx0XFxcXCcsXHJcbiAgdmF1bHRMb2NhdGlvbjogJy8nLFxyXG4gIGludGVydmFsOiA0NTAwMCxcclxuICBub3Rlc1RlbXBsYXRlOiBcIi0tLVxcbmd1aWQ6IHt7VklWQUxESV9HVUlEfX1cXG51cmw6IHt7VVJMfX1cXG5kYXRlX2NyZWF0ZWQ6IHt7REFURV9DUkVBVEVEfX1cXG4tLS1cXG57e0NPTlRFTlR9fVxcbi0tLVxcbnt7SU1BR0VTfX1cXG5cXG5cIlxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFZpdmFsZGlOb3Rlc1NldHRpbmd0VGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgcGx1Z2luOiBWaXZhbGRpTm90ZXNQbHVnaW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFZpdmFsZGlOb3Rlc1BsdWdpbikge1xyXG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICBcclxuICB9XHJcbiAgXHJcbiAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblxyXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuICAgIFxyXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnVml2YWxkaSBOb3RlcyBQbHVnaW4nIH0pXHJcbiAgICBcclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnVml2YWxkaSBub3RlcyBwYXRoIG5vdGVzIHBhdGgnKVxyXG4gICAgICAuc2V0RGVzYygnVGhlIHBhdGggd2hlcmUgdml2YWxkaSBzdG9yZSB5b3VyIG5vdGVzLiBZb3UgY2FuIGZpbmQgaXQgZW50ZXJpbmcgdml2YWxkaTovL2Fib3V0LyBvbiB5b3VyIHZpdmFsZGkgYnJvd3NlciB1bmRlciB0aGUgVXNlciBQcm9maWxlIHNlY3Rpb24uJylcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdDOlxcXFxVc2Vyc1xcXFxVc2VyXFxcXEFwcERhdGFcXFxcTG9jYWxcXFxcVml2YWxkaVxcXFxVc2VyIERhdGFcXFxcRGVmYXVsdFxcXFwnKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGVzUGF0aClcclxuICAgICAgICAgIC5vbkNoYW5nZSgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90ZXNQYXRoID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnTmV3IG5vdGUgcGF0aCcpXHJcbiAgICAgIC5zZXREZXNjKCdUaGUgcGF0aCB3aGVyZSB0aGUgbmV3IG5vdGVzIHdpbGwgYmUgY3JlYXRlZC4nKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgdGV4dFxyXG4gICAgICAuc2V0UGxhY2Vob2xkZXIoJy8nKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0TG9jYXRpb24pXHJcbiAgICAgICAgICAub25DaGFuZ2UoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnZhdWx0TG9jYXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC8vIC5hZGRTZWFyY2goKHNlYXJjaCkgPT4ge1xyXG4gICAgICAgICAgICAvLyAgIHNlYXJjaC5zZXRQbGFjZWhvbGRlcignU2VhcmNoIGZvciB2YXVsdCBsb2NhdGlvbicpLnNldERpc2FibGVkKHRydWUpO1xyXG4gICAgICAgICAgICAvLyB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgLnNldE5hbWUoJ1RlbXBsYXRlIGZvciBuZXcgbm90ZXMnKVxyXG4gICAgICAgIC5zZXREZXNjKCdUaGUgdGVtcGxhdGVzIG9mIHRoZSBub3RlIHRoYXQgd2lsbCBiZSBjcmVhdGVkLiBcXG4gWW91IGNhbiB1c2UgdGhlIGZvbGxvd2luZyB2YXJpYWJsZXM6IHt7VklWQUxESV9HVUlEfX0sIHt7VVJMfX0sIHt7REFURV9DUkVBVEVEfX0sIHt7Q09OVEVOVH19LCB7e0lNQUdFU319LiBDb250ZW50IGlzIHJlcXVpcmVkJylcclxuICAgICAgICAuYWRkVGV4dEFyZWEoKHRleHQpID0+eyAgICAgIFxyXG4gICAgICAgICAgdGV4dC5pbnB1dEVsLnJvd3MgPSAyMDtcclxuICAgICAgICAgIHRleHQuaW5wdXRFbC5jb2xzID0gNTA7XHJcbiAgICAgICAgICByZXR1cm4gdGV4dFxyXG4gICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJy0tLVxcbmd1aWQ6IHt7VklWQUxESV9HVUlEfX1cXG51cmw6IHt7VVJMfX1cXG5kYXRlX2NyZWF0ZWQ6e3tEQVRFX0NSRUFURUR9fVxcbi0tLVxcbnt7Q09OVEVOVH19XFxuLS0tXFxue3tJTUFHRVN9fVxcblxcbicpXHJcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3Rlc1RlbXBsYXRlKVxyXG4gICAgICAgICAgICAub25DaGFuZ2UoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90ZXNUZW1wbGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgLnNldE5hbWUoJ0ludGVydmFsIGZvciBjaGVja2luZyBuZXcgbm90ZXMnKVxyXG4gICAgICAgIC5zZXREZXNjKCdUaGUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIGZvciBjaGVja2luZyBuZXcgbm90ZXMnKVxyXG4gICAgICAgIC5hZGRTbGlkZXIoKG51bWJlcikgPT5cclxuICAgICAgICAgIG51bWJlclxyXG4gICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXHJcbiAgICAgICAgICAgICAgLnNldExpbWl0cygxMDAsIDYwMDAwMCwgNTAwMClcclxuICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW50ZXJ2YWwpXHJcbiAgICAgICAgICAgICAgLm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW50ZXJ2YWw9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICBcclxuICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdieSBBcnR1cm8gRGF2aWQgUmVib2xsZWRvIFJvc2Vuc3RpZWhsIGZyb20gQmFycmFucXVpbGxhLCBDb2xvbWJpYScsIGF0dHI6IHsgc3R5bGU6ICd0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQtc2l6ZTogMC44ZW07IGNvbG9yOiAjODg4OyBtYXJnaW4tdG9wOiAyMHB4JyB9fSk7XHJcblxyXG4gICAgICB9XHJcbiAgICB9IiwgImltcG9ydCB7IEl0ZW1WaWV3LCBOb3RpY2UsIFRGaWxlLCBXb3Jrc3BhY2VMZWFmLCBkZWJvdW5jZSwgbm9ybWFsaXplUGF0aCwgcGFyc2VZYW1sLCBzZXRJY29uICB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgZ2V0Rmlyc3RMaW5lV2l0aG91dEhhc2ggfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgVml2YWxkaU5vdGVzUGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCBGdXNlIGZyb20gXCJmdXNlLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBWSUVXX1RZUEUgPSBcInZpdmFsZGktbm90ZXMtdmlld1wiO1xuXG5pbnRlcmZhY2UgTm90ZSB7XG4gIGRhdGVfYWRkZWQ6IG51bWJlclxuICBjb250ZW50OiBzdHJpbmc7XG4gIGd1aWQ6IHN0cmluZztcbiAgaWQ6IG51bWJlcjtcbiAgdHlwZTogXCJub3RlXCIgfCBcImZvbGRlclwiIHwgXCJhdHRhY2htZW50XCI7XG4gIHVybDogc3RyaW5nO1xuICBjaGlsZHJlbjogTm90ZVtdO1xuICBzdWJqZWN0Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTm90ZXMge1xuICBjaGVja3N1bTogc3RyaW5nO1xuICBjaGlsZHJlbjogTm90ZVtdO1xufVxuXG5pbnRlcmZhY2UgQXBwTm90ZSBleHRlbmRzIE5vdGUge1xuICB0aXRsZTogc3RyaW5nO1xuICBpc0FscmVhZHlDcmVhdGVkPzogYm9vbGVhbjtcbn1cblxuY29uc3QgVklWQUxESV9OT1RFU19QQVRIX1dJTiA9IFwiQzpcXFxcVXNlcnNcXFxcVVNVQVJJT1xcXFxBcHBEYXRhXFxcXExvY2FsXFxcXFZpdmFsZGlcXFxcVXNlciBEYXRhXFxcXERlZmF1bHRcXFxcXCI7XG5jb25zdCBWSVZBTERJX05PVEVTX1BBVEhfTElOID0gXCIvbW50L2MvVXNlcnMvVVNVQVJJTy9BcHBEYXRhL0xvY2FsL1ZpdmFsZGkvVXNlclxcIERhdGEvRGVmYXVsdC9cIjtcblxuXG5leHBvcnQgY2xhc3MgVml2YWxkaU5vdGVzVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgcGx1Z2luOiBWaXZhbGRpTm90ZXNQbHVnaW47XG4gIC8vIHJvb3Q6IFJvb3QgfCBudWxsID0gbnVsbDtcbiAgLy8gc2V0dGluZ3M6XG4gIHByZXZpb3VzQ2hlY2tzdW06IHN0cmluZyA9IFwiXCI7XG4gIGZ1c2U6IEZ1c2U8QXBwTm90ZT4gfCBudWxsID0gbnVsbDtcbiAgZmlsdGVyZWROb3Rlc0xpc3Q6IEFwcE5vdGVbXTsgLy8gVEhlIGZpbHRlcmVkIGxpc3RzIG9mIG5vdGVzIHRvIGJlIGRpc3BsYXllZFxuICBhcHBOb3RlczogIEFwcE5vdGVbXTsgLy8gQWxsIHRoZSBub3Rlc1xuICBvcHRpb25zID0ge1xuICAgIGluY2x1ZGVTY29yZTogdHJ1ZSxcbiAgICBrZXlzOiBbe25hbWU6J3RpdGxlJywgd2VpZ2h0OiAwLjZ9LHtuYW1lOidjb250ZW50Jywgd2VpZ2h0OiAwLjF9LCB7bmFtZTonaWQnLCB3ZWlnaHQ6IDAuM31dXG4gIH1cbiAgcmVuZGVyZWRMaXN0OkhUTUxVTGlzdEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgaW50ZXJ2YWxJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgXG4gIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYsIHBsdWdpbjogVml2YWxkaU5vdGVzUGx1Z2luKSB7XG4gICAgc3VwZXIobGVhZik7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gIH1cblxuICAvLyBub3RlcyA9IGdldE5vdGVzSlNPTigpXG5cbiAgZ2V0Vmlld1R5cGUoKSB7XG4gICAgcmV0dXJuIFZJRVdfVFlQRTtcbiAgfVxuICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICByZXR1cm4gXCJWaXZhbGRpIE5vdGVzIFZpZXdlclwiO1xuICB9XG4gIGdldEljb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJmaWxlLWNoZWNrLTJcIjtcbiAgfVxuICBcbiAgXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBjb25zb2xlLmxvZyhcIk9wZW5lZCBWaXZhbGRpIE5vdGVzIFZpZXdlclwiKVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWwuY2hpbGRyZW5bMV07XG4gICAgY29udGFpbmVyLmVtcHR5KCk7XG4gICAgY29udGFpbmVyLmNyZWF0ZUVsKFwiaDRcIiwgeyB0ZXh0OiBcIlZpdmFsZGkgTm90ZXNcIiB9KTtcbiAgICBjb25zdCB7bm90ZXMsIGNoZWNrc3VtOiBwckNoZWNrc3VtfSA9IGF3YWl0IHRoaXMuZ2V0Tm90ZXNKU09OKFZJVkFMRElfTk9URVNfUEFUSF9XSU4pXG4gICAgdGhpcy5wcmV2aW91c0NoZWNrc3VtID0gcHJDaGVja3N1bTtcblxuXG4gICAgdGhpcy5hcHBOb3RlcyA9IG5vdGVzLm1hcCgobm90ZSkgPT4ge1xuICAgICAgbGV0IHRpdGxlID0gZ2V0Rmlyc3RMaW5lV2l0aG91dEhhc2gobm90ZS5jb250ZW50KTtcbiAgICAgIHJldHVybiB7IC4uLm5vdGUsIHRpdGxlIH07IC8vIFRoaXMgY3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCBhbGwgcHJvcGVydGllcyBvZiBub3RlIGFuZCB0aGUgbmV3IHRpdGxlIHByb3BlcnR5XG4gICAgfSk7XG5cbiAgICB0aGlzLmZ1c2UgPSBuZXcgRnVzZSh0aGlzLmFwcE5vdGVzLCB0aGlzLm9wdGlvbnMpXG5cbiAgICB0aGlzLmZpbHRlcmVkTm90ZXNMaXN0ID0gdGhpcy5hcHBOb3Rlc1xuXG4gICAgY29uc3Qgc2VhcmNoQmFyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiaW5wdXRcIiwgeyBjbHM6XCJzZWFyY2gtYmFyXCIsIGF0dHI6IHsgdHlwZTogXCJzZWFyY2hcIiwgcGxhY2Vob2xkZXI6IFwiU2VhcmNoLi4uXCIsIGVudGVyS2V5aGludDpcInNlYXJjaFwiIH0gfSk7XG4gICAgdGhpcy5yZW5kZXJlZExpc3QgPSBjb250YWluZXIuY3JlYXRlRWwoXCJ1bFwiLCB7IGNsczogXCJ2aXZhbGRpLW5vdGVzLWxpc3RcIiB9KTtcblxuICAgIHNlYXJjaEJhci5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZGVib3VuY2UoKGU6SW5wdXRFdmVudCkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gKGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlXG4gICAgICBpZih2YWx1ZSE9IG51bGwgJiYgdmFsdWUgIT0gdW5kZWZpbmVkICYmIHZhbHVlICE9IFwiXCIgJiYgdGhpcy5mdXNlKSB7XG4gICAgICAgIGxldCByZXN1bHRhZG8gPSB0aGlzLmZ1c2Uuc2VhcmNoKHZhbHVlKVxuICAgICAgICB0aGlzLmZpbHRlcmVkTm90ZXNMaXN0ID0gcmVzdWx0YWRvLm1hcCgobm90ZSkgPT4gbm90ZS5pdGVtKVxuXG4gICAgICAgIHdoaWxlICh0aGlzLnJlbmRlcmVkTGlzdD8uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRMaXN0Py5yZW1vdmVDaGlsZCh0aGlzLnJlbmRlcmVkTGlzdC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5maWx0ZXJlZE5vdGVzTGlzdCAhPSBudWxsKSB7dGhpcy5yZW5kZXJOb3Rlcyh0aGlzLmZpbHRlcmVkTm90ZXNMaXN0KX1cblxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIlwiKSB7XG4gICAgICAgIC8vIHdoaWxlICh1bC5maXJzdENoaWxkKSB7XG4gICAgICAgIC8vICAgdWwucmVtb3ZlQ2hpbGQodWwuZmlyc3RDaGlsZCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdGhpcy5yZW5kZXJOb3Rlcyh0aGlzLmFwcE5vdGVzKVxuICAgICAgfVxuICAgIH0sIDEyMCkpXG5cbiAgICB0aGlzLnJlbmRlck5vdGVzKHRoaXMuYXBwTm90ZXMpXG5cbiAgICB0aGlzLmludGVydmFsSWQgPSB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwoMSk7XG4gIH1cblxuICBvbnZpZXd3aWxsdW5sb2FkKCkge1xuICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RlckludGVydmFsKGlkOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGludGVydmFsVGltZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmludGVydmFsXG4gICAgcmV0dXJuIHdpbmRvdy5zZXRJbnRlcnZhbChhc3luYygpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGVja3N1bSA9IGF3YWl0IHRoaXMuZ2V0Tm90ZXNDaGVja3N1bSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3Rlc1BhdGgpO1xuICAgICAgY29uc29sZS5sb2coY3VycmVudENoZWNrc3VtKVxuICAgICAgLy8gSWYgdGhlIGNoZWNrc3VtIGhhcyBjaGFuZ2VkLCByZS1yZW5kZXIgdGhlIGxpc3RcbiAgICAgIGlmIChjdXJyZW50Q2hlY2tzdW0gIT09IHRoaXMucHJldmlvdXNDaGVja3N1bSkge1xuICAgICAgICBjb25zdCB7bm90ZXM6bmV3Tm90ZXNMaXN0fSA9IGF3YWl0IHRoaXMuZ2V0Tm90ZXNKU09OKHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGVzUGF0aCk7XG5cbiAgICAgICAgdGhpcy5hcHBOb3RlcyA9IG5ld05vdGVzTGlzdC5tYXAoKG5vdGUpID0+IHtcbiAgICAgICAgICBsZXQgdGl0bGUgPSBnZXRGaXJzdExpbmVXaXRob3V0SGFzaChub3RlLmNvbnRlbnQpO1xuICAgICAgICAgIHJldHVybiB7IC4uLm5vdGUsIHRpdGxlIH07IC8vIFRoaXMgY3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCBhbGwgcHJvcGVydGllcyBvZiBub3RlIGFuZCB0aGUgbmV3IHRpdGxlIHByb3BlcnR5XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5mdXNlID0gbmV3IEZ1c2UodGhpcy5hcHBOb3RlcywgdGhpcy5vcHRpb25zKVxuXG4gICAgICAgIGxldCBub3Rlc0xpc3QgPSB0aGlzLmFwcE5vdGVzXG5cbiAgICAgICAgd2hpbGUgKHRoaXMucmVuZGVyZWRMaXN0Py5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlZExpc3Q/LnJlbW92ZUNoaWxkKHRoaXMucmVuZGVyZWRMaXN0Py5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMucmVuZGVyTm90ZXMobm90ZXNMaXN0KTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NoZWNrc3VtID0gY3VycmVudENoZWNrc3VtO1xuICAgICAgfVxuXG4gICAgfSwgaW50ZXJ2YWxUaW1lKTtcbiAgfVxuXG4gIGFzeW5jIHJlbmRlck5vdGVzKGxpc3Q6QXBwTm90ZVtdKXtcbiAgICBhd2FpdCBsaXN0LmZpbHRlcigobm90ZSkgPT4gbm90ZS50eXBlID09PSBcIm5vdGVcIiAmJiBub3RlLmNvbnRlbnQpLmZvckVhY2goKG5vdGUpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZWRMaXN0Py5jcmVhdGVFbChcImxpXCIsIHsgdGV4dDogbm90ZS50aXRsZS5sZW5ndGggPT0gNDAgPyBub3RlLnRpdGxlK1wiLi4uXCIgOiBub3RlLnRpdGxlLCBjbHM6XCJ2aXZhbGRpLW5vdGVzLWxpc3QtaXRlbVwiLCBhdHRyOntpZDogbm90ZS5pZH0gfSlcbiAgICAgICAgLm9uQ2xpY2tFdmVudChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMudmVyaWZ5Q3JlYXRlZE5vdGVzKG5vdGUudGl0bGUpKSB7XG4gICAgICAgICAgICBzZXRJY29uKChldmVudC50YXJnZXQgYXMgSFRNTExJRWxlbWVudCkuY3JlYXRlRGl2KHtjbHM6XCJjaGVjay1pY29uXCJ9KSwgXCJmaWxlLWNoZWNrLTJcIik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTm90ZSBpbXBvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVOZXdOb3RlKG5vdGUudGl0bGUsIG5vdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhd2FpdCB0aGlzLmFwcC52YXVsdC5vcGVuKG5vdGUudGl0bGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTm90ZSBhbHJlYWR5IGltcG9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub3BlbkxpbmtUZXh0KG5vdGUudGl0bGUsICcnLCBmYWxzZSk7XG4gICAgICAgICAgLy8gICAoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5pbm5lckhUTUwgKz0gYDxwPlJlZXNjcmliaXI/PC9wPmA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMudmVyaWZ5Q3JlYXRlZE5vdGVzKG5vdGUudGl0bGUpKSB7XG4gICAgICAgICAgc2V0SWNvbigodGhpcy5yZW5kZXJlZExpc3Q/Lmxhc3RFbGVtZW50Q2hpbGQgYXMgSFRNTExJRWxlbWVudCkuY3JlYXRlRGl2KHtjbHM6XCJjaGVjay1pY29uXCJ9KSwgXCJmaWxlLWNoZWNrLTJcIilcbiAgICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0Tm90ZXNKU09OKHBhdGg6c3RyaW5nKTpQcm9taXNlPHtub3RlczpOb3RlW10sIGNoZWNrc3VtOiBzdHJpbmd9PiB7XG4gICAgbGV0IHN0cmluZ3BhdGggPSBub3JtYWxpemVQYXRoKHBhdGgrIFwiL1wiICsgXCJOb3Rlc1wiKTtcbiAgICBjb25zdCBmaWxlQ29udGVudHMgPSBhd2FpdCBmcy5yZWFkRmlsZVN5bmMoc3RyaW5ncGF0aCwgJ3V0ZjgnKTtcbiAgICBsZXQgZGF0bzpOb3RlcyA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnRzKTtcbiAgICByZXR1cm4ge25vdGVzIDogZGF0by5jaGlsZHJlbiwgY2hlY2tzdW06IGRhdG8uY2hlY2tzdW19O1xuICB9XG5cbiAgYXN5bmMgZ2V0Tm90ZXNDaGVja3N1bShwYXRoOnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+IHtcbiAgICBsZXQgc3RyaW5ncGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCsgXCIvXCIgKyBcIk5vdGVzXCIpO1xuICAgIGNvbnN0IGZpbGVDb250ZW50cyA9IGF3YWl0IGZzLnJlYWRGaWxlU3luYyhzdHJpbmdwYXRoKTtcbiAgICBjb25zdCBjaGVja3N1bSA9IGZpbGVDb250ZW50cy5zbGljZSgxOSw1MSkudG9TdHJpbmcoKTtcbiAgICBcbiAgICByZXR1cm4gY2hlY2tzdW07XG4gIH1cblxuICBhc3luYyBjcmVhdGVOZXdOb3RlKHRpdGxlOnN0cmluZywgbm90ZTogTm90ZSkgIHtcbiAgICBsZXQgY29udGVudCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGVzVGVtcGxhdGVcbiAgICAgIC5yZXBsYWNlKFwie3tWSVZBTERJX0dVSUR9fVwiLCBub3RlLmd1aWQgPyBub3RlLmd1aWQgOiBcIlwiKSAgXG4gICAgICAucmVwbGFjZShcInt7VklWQUxESV9JRH19XCIsIG5vdGUuaWQgPyBub3RlLmlkLnRvU3RyaW5nKCkgOiBcIlwiKSAgXG4gICAgICAucmVwbGFjZShcInt7VVJMfX1cIiwgbm90ZS51cmwgPyBub3RlLnVybCA6IFwiXCIpXG4gICAgICAucmVwbGFjZShcInt7REFURV9DUkVBVEVEfX1cIiwgbm90ZS5kYXRlX2FkZGVkID8gbmV3IERhdGUoKG5vdGUuZGF0ZV9hZGRlZC0xMTY0NDQ3MzYwMDAwMDAwMCkgLzEwMDApLnRvSVNPU3RyaW5nKCkgOiBcIlwiKVxuICAgICAgLnJlcGxhY2UoXCJ7e0NPTlRFTlR9fVwiLCBub3RlLmNvbnRlbnQgPyBub3RlLmNvbnRlbnQgOiBcIlwiKVxuXG5cbiAgICBpZihub3RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGxldCBpbWFnZXNTdHJpbmcgPSBcIlwiXG4gICAgICAvLyBGaXggdGhpcyBTaGFpdFx1MDNCMmVcbiAgICAgIGxldCBpbWFnZUFycmF5ID0gbm90ZS5jaGlsZHJlbi5maWx0ZXIoY2hpbGQ9PmNoaWxkLnR5cGUgPT09IFwiYXR0YWNobWVudFwiKS5tYXAoKGNoaWxkKSA9PiBgXFxuPGltZyBzcmM9XCIke25vcm1hbGl6ZVBhdGgodGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90ZXNQYXRoICsgXCIvXCIgKyBcIlN5bmNlZEZpbGVzXCIgKyBcIi9cIisgY2hpbGQuY29udGVudCApfVwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cImF1dG9cIi8+XFxuYClcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoXCJ7e0lNQUdFU319XCIsIGltYWdlQXJyYXkudG9TdHJpbmcoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShcInt7SU1BR0VTfX1cIiwgXCJcIilcbiAgICB9XG5cblxuICAgIC8vIGxldCBjYXJwZXRhID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRMb2NhdGlvblxuICAgIGxldCBjYXJwZXRhID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRMb2NhdGlvbiArXCIvXCJcbiAgICBjb25zb2xlLmxvZyhjYXJwZXRhKVxuICAgIGNvbnN0IHN0cmluZ3BhdGggPSBub3JtYWxpemVQYXRoKGNhcnBldGEgKyB0aXRsZSArIFwiLm1kXCIpXG4gICAgY29uc29sZS5sb2coc3RyaW5ncGF0aClcbiAgICBjb25zdCBuZXdOb3RlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHN0cmluZ3BhdGgsIGNvbnRlbnQpO1xuICAgIC8vIG9wZW4gdGhlIGZpbGUgYWZ0ZXIgY3JlYXRpb25cbiAgICBhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2Uub3BlbkxpbmtUZXh0KG5ld05vdGUucGF0aCwgJycsIHRydWUpO1xuICAgIHJldHVybiBuZXdOb3RlO1xuICB9ICBcblxuICBhc3luYyBnZXROb3RlRmlsZShub3RlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxURmlsZT4ge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm90ZVBhdGgpOyAvLyBUT0RPIHJ1biBhbGwgdGhlIHBhdGhzIHRvIG5vcm1hbGl6ZVBhdGhcbiAgICBpZiAoIWZpbGUgfHwgIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgbm90IGZvdW5kOiAke25vdGVQYXRofWApO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIGFzeW5jIGdldE5vdGVzTWV0YWRhdGEobm90ZVBhdGhPUkNvbnRlbnRTdHJpbmc6VEZpbGUgfCBzdHJpbmcpOlByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxldCBmaWxlOnN0cmluZ1xuICAgIGlmKHR5cGVvZiBub3RlUGF0aE9SQ29udGVudFN0cmluZyA9PSBcInN0cmluZ1wiKXtcbiAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGF3YWl0IHRoaXMuZ2V0Tm90ZUZpbGUobm90ZVBhdGhPUkNvbnRlbnRTdHJpbmcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChub3RlUGF0aE9SQ29udGVudFN0cmluZylcbiAgICB9XG4gICAgY29uc3QgZnJvbnRtYXR0ZXJSZWdleCA9IC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tXFxuLztcbiAgICBjb25zdCBtYXRjaCA9IGZpbGUubWF0Y2goZnJvbnRtYXR0ZXJSZWdleCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyBcbiAgICB9XG4gICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBwYXJzZVlhbWwobWF0Y2hbMV0pO1xuICAgIHJldHVybiBmcm9udG1hdHRlcjtcbiAgfSBcblxuICB2ZXJpZnlDcmVhdGVkTm90ZXModGl0bGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIHRoZSBub3RlIGV4aXN0cyBpbiBPYnNpZGlhblxuICAgIGxldCBjYXJwZXRhID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRMb2NhdGlvbiArXCIvXCJcbiAgICBjb25zb2xlLmxvZyhjYXJwZXRhKVxuICAgIGNvbnN0IHN0cmluZ3BhdGggPSBub3JtYWxpemVQYXRoKGNhcnBldGEgKyB0aXRsZSArIFwiLm1kXCIpXG4gICAgY29uc3Qgbm90ZUV4aXN0cyA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzdHJpbmdwYXRoKSAhPT0gbnVsbDtcbiAgICByZXR1cm4gbm90ZUV4aXN0cztcbiAgfVxuXG4gIGFzeW5jIG9uQ2xvc2UoKSB7XG4gICAgY29uc29sZS5sb2coXCJDbG9zZWQgVml2YWxkaSBOb3RlcyBWaWV3ZXIsIHN0b3BwZWQgaW50ZXJ2YWxcIilcbiAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgfVxuICB9XG5cbn1cbiIsICJcclxuXHJcbmNvbnN0IFZJVkFMRElfTk9URVNfUEFUSF9XSU4gPSBcIkM6XFxVc2Vyc1xcVVNVQVJJT1xcQXBwRGF0YVxcTG9jYWxcXFZpdmFsZGlcXFVzZXIgRGF0YVxcRGVmYXVsdFxcXFxcIjtcclxuY29uc3QgVklWQUxESV9OT1RFU19QQVRIX0xJTiA9IFwiL21udC9jL1VzZXJzL1VTVUFSSU8vQXBwRGF0YS9Mb2NhbC9WaXZhbGRpL1VzZXJcXCBEYXRhL0RlZmF1bHQvXCI7XHJcbmV4cG9ydCBjb25zdCBNQVhfV0lEVEhfVElUTEUgPSA2MDtcclxuXHJcblxyXG5pbnRlcmZhY2UgTm90ZSB7XHJcbiAgZGF0ZV9hZGRlZDogbnVtYmVyO1xyXG4gIGNvbnRlbnQ6IHN0cmluZztcclxuICBndWlkOiBzdHJpbmc7XHJcbiAgaWQ6IG51bWJlcjtcclxuICB0eXBlOiBzdHJpbmc7XHJcbiAgdXJsOiBzdHJpbmc7XHJcbiAgY2hpbGRyZW46IE5vdGVbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIE5vdGVzIHtcclxuICBjaGVja3N1bTogc3RyaW5nO1xyXG4gIGNoaWxkcmVuOiBOb3RlW107XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3RMaW5lV2l0aG91dEhhc2goc3RyOnN0cmluZyk6c3RyaW5nIHtcclxuICBjb25zdCByZWdleCA9IC9eKD86I3xcXHJ8XFxuKSpbIF0qLio/KFteXFxuXXswLDQwfSkvZ21zO1xyXG4gIGlmIChzdHIgPT0gXCJcIiB8fCBzdHIgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIFwiXCI7XHJcbiAgfVxyXG4gIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhzdHIpO1xyXG4gIGlmIChtYXRjaCkge1xyXG4gICAgbGV0IGZpcnN0TGluZT0gbWF0Y2hbMV0ucmVwbGFjZSgvW1xcXFxcXC88Pjp8P1wiLV0vZywgJycpO1xyXG4gICAgcmV0dXJuIGZpcnN0TGluZS5yZXBsYWNlKC9bLlxcc10rJC8sICcnKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBcIlwiO1xyXG59XHJcblxyXG5cclxuXHJcbi8vIGdldEZpcnN0TGluZVdpdGhvdXRIYXNoKFwiIyBQZWxpY3VsYXMgUXVlIFZlclxcblxcbi0gVGVuIExpdHRsZSBNaXN0cmVzc1xcbi0gaGlzIE9ubHkgU29uXFxuLSBKaG9uIFdlZWsgNFxcbi0gQ2l0YWRlbCBcXG4tIE9oIGJlbGluZGFcXG4tIEN1YW50dW0gbWFuXHUwMEVEYVxcbi0gU2VuZWNhXFxuLSBHaG9zdGVkIFxcbi0gT3RoZXIgcGVvcGxlXFxuLSBUaGUgcG9wZSBFeG9yY2lzdFxcbi0gQmF0bWFuIERvb21cXG4tIER1bmdlb25zIEFuZCBEcmFnb25zXCIpXHJcblxyXG5cclxuXHJcbi8vIGdldE5vdGVzSlNPTigpIiwgIi8qKlxuICogRnVzZS5qcyB2Ny4wLjAgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIzIEtpcm8gUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheVxuICAgID8gZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG5jb25zdCBJTkZJTklUWSA9IDEgLyAwO1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Jvb2xlYW4uanNcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSB0cnVlIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSAnW29iamVjdCBCb29sZWFuXScpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuLy8gQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlLnRyaW0oKS5sZW5ndGhcbn1cblxuLy8gR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJ1tvYmplY3QgVW5kZWZpbmVkXSdcbiAgICAgIDogJ1tvYmplY3QgTnVsbF0nXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmNvbnN0IEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSA9ICdFeHRlbmRlZCBzZWFyY2ggaXMgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IElOQ09SUkVDVF9JTkRFWF9UWVBFID0gXCJJbmNvcnJlY3QgJ2luZGV4JyB0eXBlXCI7XG5cbmNvbnN0IExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSA9IChrZXkpID0+XG4gIGBJbnZhbGlkIHZhbHVlIGZvciBrZXkgJHtrZXl9YDtcblxuY29uc3QgUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFID0gKG1heCkgPT5cbiAgYFBhdHRlcm4gbGVuZ3RoIGV4Y2VlZHMgbWF4IG9mICR7bWF4fS5gO1xuXG5jb25zdCBNSVNTSU5HX0tFWV9QUk9QRVJUWSA9IChuYW1lKSA9PiBgTWlzc2luZyAke25hbWV9IHByb3BlcnR5IGluIGtleWA7XG5cbmNvbnN0IElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSA9IChrZXkpID0+XG4gIGBQcm9wZXJ0eSAnd2VpZ2h0JyBpbiBrZXkgJyR7a2V5fScgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xuXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jbGFzcyBLZXlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fa2V5TWFwID0ge307XG5cbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCBvYmogPSBjcmVhdGVLZXkoa2V5KTtcblxuICAgICAgdGhpcy5fa2V5cy5wdXNoKG9iaik7XG4gICAgICB0aGlzLl9rZXlNYXBbb2JqLmlkXSA9IG9iajtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzIHNvIHRoYXQgdGhlaXIgc3VtIGlzIGVxdWFsIHRvIDFcbiAgICB0aGlzLl9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAga2V5LndlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICB9KTtcbiAgfVxuICBnZXQoa2V5SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5TWFwW2tleUlkXVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2tleXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICBsZXQgcGF0aCA9IG51bGw7XG4gIGxldCBpZCA9IG51bGw7XG4gIGxldCBzcmMgPSBudWxsO1xuICBsZXQgd2VpZ2h0ID0gMTtcbiAgbGV0IGdldEZuID0gbnVsbDtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBpc0FycmF5KGtleSkpIHtcbiAgICBzcmMgPSBrZXk7XG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgoa2V5KTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChrZXksICduYW1lJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0tFWV9QUk9QRVJUWSgnbmFtZScpKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBrZXkubmFtZTtcbiAgICBzcmMgPSBuYW1lO1xuXG4gICAgaWYgKGhhc093bi5jYWxsKGtleSwgJ3dlaWdodCcpKSB7XG4gICAgICB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuXG4gICAgICBpZiAod2VpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRShuYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChuYW1lKTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKG5hbWUpO1xuICAgIGdldEZuID0ga2V5LmdldEZuO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aCwgaWQsIHdlaWdodCwgc3JjLCBnZXRGbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVBhdGgoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoJy4nKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlJZChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleS5qb2luKCcuJykgOiBrZXlcbn1cblxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICBsZXQgbGlzdCA9IFtdO1xuICBsZXQgYXJyID0gZmFsc2U7XG5cbiAgY29uc3QgZGVlcEdldCA9IChvYmosIHBhdGgsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQob2JqKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcGF0aFtpbmRleF0pIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGF0aCBsZWZ0LCB3ZSd2ZSBhcnJpdmVkIGF0IHRoZSBvYmplY3Qgd2UgY2FyZSBhYm91dC5cbiAgICAgIGxpc3QucHVzaChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQga2V5ID0gcGF0aFtpbmRleF07XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIHBhdGgsIGFuZCBpZiBpdCdzIGEgc3RyaW5nL251bWJlci9ib29sLFxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSlcbiAgICAgICkge1xuICAgICAgICBsaXN0LnB1c2godG9TdHJpbmcodmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYXJyID0gdHJ1ZTtcbiAgICAgICAgLy8gU2VhcmNoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGRlZXBHZXQodmFsdWVbaV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQW4gb2JqZWN0LiBSZWN1cnNlIGZ1cnRoZXIuXG4gICAgICAgIGRlZXBHZXQodmFsdWUsIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzaW5jZSBwYXRoIHVzZWQgdG8gYmUgYSBzdHJpbmcpXG4gIGRlZXBHZXQob2JqLCBpc1N0cmluZyhwYXRoKSA/IHBhdGguc3BsaXQoJy4nKSA6IHBhdGgsIDApO1xuXG4gIHJldHVybiBhcnIgPyBsaXN0IDogbGlzdFswXVxufVxuXG5jb25zdCBNYXRjaE9wdGlvbnMgPSB7XG4gIC8vIFdoZXRoZXIgdGhlIG1hdGNoZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBXaGVuIGB0cnVlYCwgZWFjaCByZWNvcmQgaW4gdGhlIHJlc3VsdFxuICAvLyBzZXQgd2lsbCBpbmNsdWRlIHRoZSBpbmRpY2VzIG9mIHRoZSBtYXRjaGVkIGNoYXJhY3RlcnMuXG4gIC8vIFRoZXNlIGNhbiBjb25zZXF1ZW50bHkgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzLlxuICBpbmNsdWRlTWF0Y2hlczogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICAvLyBhIHBlcmZlY3QgbWF0Y2ggaGFzIGFscmVhZHkgYmVlbiBsb2NhdGVkIGluIHRoZSBzdHJpbmcuXG4gIGZpbmRBbGxNYXRjaGVzOiBmYWxzZSxcbiAgLy8gTWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgbWF0Y2hlZCBiZWZvcmUgYSByZXN1bHQgaXMgY29uc2lkZXJlZCBhIG1hdGNoXG4gIG1pbk1hdGNoQ2hhckxlbmd0aDogMVxufTtcblxuY29uc3QgQmFzaWNPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGFsZ29yaXRobSBjb250aW51ZXMgc2VhcmNoaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IGV2ZW4gaWYgYSBwZXJmZWN0XG4gIC8vIG1hdGNoIGlzIGZvdW5kIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzYW1lIGlucHV0LlxuICBpc0Nhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAvLyBXaGVuIHRydWUsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIGluY2x1ZGVTY29yZTogZmFsc2UsXG4gIC8vIExpc3Qgb2YgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQuIFRoaXMgYWxzbyBzdXBwb3J0cyBuZXN0ZWQgcHJvcGVydGllcy5cbiAga2V5czogW10sXG4gIC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgcmVzdWx0IGxpc3QsIGJ5IHNjb3JlXG4gIHNob3VsZFNvcnQ6IHRydWUsXG4gIC8vIERlZmF1bHQgc29ydCBmdW5jdGlvbjogc29ydCBieSBhc2NlbmRpbmcgc2NvcmUsIGFzY2VuZGluZyBpbmRleFxuICBzb3J0Rm46IChhLCBiKSA9PlxuICAgIGEuc2NvcmUgPT09IGIuc2NvcmUgPyAoYS5pZHggPCBiLmlkeCA/IC0xIDogMSkgOiBhLnNjb3JlIDwgYi5zY29yZSA/IC0xIDogMVxufTtcblxuY29uc3QgRnV6enlPcHRpb25zID0ge1xuICAvLyBBcHByb3hpbWF0ZWx5IHdoZXJlIGluIHRoZSB0ZXh0IGlzIHRoZSBwYXR0ZXJuIGV4cGVjdGVkIHRvIGJlIGZvdW5kP1xuICBsb2NhdGlvbjogMCxcbiAgLy8gQXQgd2hhdCBwb2ludCBkb2VzIHRoZSBtYXRjaCBhbGdvcml0aG0gZ2l2ZSB1cC4gQSB0aHJlc2hvbGQgb2YgJzAuMCcgcmVxdWlyZXMgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIChvZiBib3RoIGxldHRlcnMgYW5kIGxvY2F0aW9uKSwgYSB0aHJlc2hvbGQgb2YgJzEuMCcgd291bGQgbWF0Y2ggYW55dGhpbmcuXG4gIHRocmVzaG9sZDogMC42LFxuICAvLyBEZXRlcm1pbmVzIGhvdyBjbG9zZSB0aGUgbWF0Y2ggbXVzdCBiZSB0byB0aGUgZnV6enkgbG9jYXRpb24gKHNwZWNpZmllZCBhYm92ZSkuXG4gIC8vIEFuIGV4YWN0IGxldHRlciBtYXRjaCB3aGljaCBpcyAnZGlzdGFuY2UnIGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBmdXp6eSBsb2NhdGlvblxuICAvLyB3b3VsZCBzY29yZSBhcyBhIGNvbXBsZXRlIG1pc21hdGNoLiBBIGRpc3RhbmNlIG9mICcwJyByZXF1aXJlcyB0aGUgbWF0Y2ggYmUgYXRcbiAgLy8gdGhlIGV4YWN0IGxvY2F0aW9uIHNwZWNpZmllZCwgYSB0aHJlc2hvbGQgb2YgJzEwMDAnIHdvdWxkIHJlcXVpcmUgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIHRvIGJlIHdpdGhpbiA4MDAgY2hhcmFjdGVycyBvZiB0aGUgZnV6enkgbG9jYXRpb24gdG8gYmUgZm91bmQgdXNpbmcgYSAwLjggdGhyZXNob2xkLlxuICBkaXN0YW5jZTogMTAwXG59O1xuXG5jb25zdCBBZHZhbmNlZE9wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCBpdCBlbmFibGVzIHRoZSB1c2Ugb2YgdW5peC1saWtlIHNlYXJjaCBjb21tYW5kc1xuICB1c2VFeHRlbmRlZFNlYXJjaDogZmFsc2UsXG4gIC8vIFRoZSBnZXQgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZmV0Y2hpbmcgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gVGhlIGRlZmF1bHQgd2lsbCBzZWFyY2ggbmVzdGVkIHBhdGhzICppZSBmb28uYmFyLmJheipcbiAgZ2V0Rm46IGdldCxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHNlYXJjaCB3aWxsIGlnbm9yZSBgbG9jYXRpb25gIGFuZCBgZGlzdGFuY2VgLCBzbyBpdCB3b24ndCBtYXR0ZXJcbiAgLy8gd2hlcmUgaW4gdGhlIHN0cmluZyB0aGUgcGF0dGVybiBhcHBlYXJzLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZnV6emluZXNzLXNjb3JlXG4gIGlnbm9yZUxvY2F0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIHJlbGV2YW5jZSBzY29yZSAodXNlZCBmb3Igc29ydGluZykgd2lsbFxuICAvLyBpZ25vcmUgdGhlIGZpZWxkLWxlbmd0aCBub3JtLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZmllbGQtbGVuZ3RoLW5vcm1cbiAgaWdub3JlRmllbGROb3JtOiBmYWxzZSxcbiAgLy8gVGhlIHdlaWdodCB0byBkZXRlcm1pbmUgaG93IG11Y2ggZmllbGQgbGVuZ3RoIG5vcm0gZWZmZWN0cyBzY29yaW5nLlxuICBmaWVsZE5vcm1XZWlnaHQ6IDFcbn07XG5cbnZhciBDb25maWcgPSB7XG4gIC4uLkJhc2ljT3B0aW9ucyxcbiAgLi4uTWF0Y2hPcHRpb25zLFxuICAuLi5GdXp6eU9wdGlvbnMsXG4gIC4uLkFkdmFuY2VkT3B0aW9uc1xufTtcblxuY29uc3QgU1BBQ0UgPSAvW14gXSsvZztcblxuLy8gRmllbGQtbGVuZ3RoIG5vcm06IHRoZSBzaG9ydGVyIHRoZSBmaWVsZCwgdGhlIGhpZ2hlciB0aGUgd2VpZ2h0LlxuLy8gU2V0IHRvIDMgZGVjaW1hbHMgdG8gcmVkdWNlIGluZGV4IHNpemUuXG5mdW5jdGlvbiBub3JtKHdlaWdodCA9IDEsIG1hbnRpc3NhID0gMykge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbSA9IE1hdGgucG93KDEwLCBtYW50aXNzYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bVRva2VucyA9IHZhbHVlLm1hdGNoKFNQQUNFKS5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMobnVtVG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG51bVRva2VucylcbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiBpcyAxL3NxcnQoeCksIHdlaWdodCBtYWtlcyB0aGF0IHZhcmlhYmxlXG4gICAgICBjb25zdCBub3JtID0gMSAvIE1hdGgucG93KG51bVRva2VucywgMC41ICogd2VpZ2h0KTtcblxuICAgICAgLy8gSW4gcGxhY2Ugb2YgYHRvRml4ZWQobWFudGlzc2EpYCwgZm9yIGZhc3RlciBjb21wdXRhdGlvblxuICAgICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoTWF0aC5yb3VuZChub3JtICogbSkgLyBtKTtcblxuICAgICAgY2FjaGUuc2V0KG51bVRva2Vucywgbik7XG5cbiAgICAgIHJldHVybiBuXG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1c2VJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZXRGbiA9IENvbmZpZy5nZXRGbixcbiAgICBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHRoaXMubm9ybSA9IG5vcm0oZmllbGROb3JtV2VpZ2h0LCAzKTtcbiAgICB0aGlzLmdldEZuID0gZ2V0Rm47XG4gICAgdGhpcy5pc0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0SW5kZXhSZWNvcmRzKCk7XG4gIH1cbiAgc2V0U291cmNlcyhkb2NzID0gW10pIHtcbiAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICB9XG4gIHNldEluZGV4UmVjb3JkcyhyZWNvcmRzID0gW10pIHtcbiAgICB0aGlzLnJlY29yZHMgPSByZWNvcmRzO1xuICB9XG4gIHNldEtleXMoa2V5cyA9IFtdKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLl9rZXlzTWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGlkeCkgPT4ge1xuICAgICAgdGhpcy5fa2V5c01hcFtrZXkuaWRdID0gaWR4O1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0NyZWF0ZWQgfHwgIXRoaXMuZG9jcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaXNDcmVhdGVkID0gdHJ1ZTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8U3RyaW5nPlxuICAgIGlmIChpc1N0cmluZyh0aGlzLmRvY3NbMF0pKSB7XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5vcm0uY2xlYXIoKTtcbiAgfVxuICAvLyBBZGRzIGEgZG9jIHRvIHRoZSBlbmQgb2YgdGhlIGluZGV4XG4gIGFkZChkb2MpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNpemUoKTtcblxuICAgIGlmIChpc1N0cmluZyhkb2MpKSB7XG4gICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBpZHgpO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmVzIHRoZSBkb2MgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvZiB0aGUgaW5kZXhcbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgLy8gQ2hhbmdlIHJlZiBpbmRleCBvZiBldmVyeSBzdWJzcXVlbnQgZG9jXG4gICAgZm9yIChsZXQgaSA9IGlkeCwgbGVuID0gdGhpcy5zaXplKCk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5yZWNvcmRzW2ldLmkgLT0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX2tleXNNYXBba2V5SWRdXVxuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5sZW5ndGhcbiAgfVxuICBfYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpIHx8IGlzQmxhbmsoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJlY29yZCA9IHtcbiAgICAgIHY6IGRvYyxcbiAgICAgIGk6IGRvY0luZGV4LFxuICAgICAgbjogdGhpcy5ub3JtLmdldChkb2MpXG4gICAgfTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KSB7XG4gICAgbGV0IHJlY29yZCA9IHsgaTogZG9jSW5kZXgsICQ6IHt9IH07XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgdGhpcy5rZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS5nZXRGbiA/IGtleS5nZXRGbihkb2MpIDogdGhpcy5nZXRGbihkb2MsIGtleS5wYXRoKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbeyBuZXN0ZWRBcnJJbmRleDogLTEsIHZhbHVlIH1dO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7IG5lc3RlZEFyckluZGV4LCB2YWx1ZSB9ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgICAgICBpOiBuZXN0ZWRBcnJJbmRleCxcbiAgICAgICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN1YlJlY29yZHMucHVzaChzdWJSZWNvcmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGspID0+IHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgbmVzdGVkQXJySW5kZXg6IGssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZHM7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICByZWNvcmRzOiB0aGlzLnJlY29yZHNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgoXG4gIGtleXMsXG4gIGRvY3MsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cy5tYXAoY3JlYXRlS2V5KSk7XG4gIG15SW5kZXguc2V0U291cmNlcyhkb2NzKTtcbiAgbXlJbmRleC5jcmVhdGUoKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gcGFyc2VJbmRleChcbiAgZGF0YSxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IGRhdGE7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMpO1xuICBteUluZGV4LnNldEluZGV4UmVjb3JkcyhyZWNvcmRzKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlJDEoXG4gIHBhdHRlcm4sXG4gIHtcbiAgICBlcnJvcnMgPSAwLFxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IDAsXG4gICAgZXhwZWN0ZWRMb2NhdGlvbiA9IDAsXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgYWNjdXJhY3kgPSBlcnJvcnMgLyBwYXR0ZXJuLmxlbmd0aDtcblxuICBpZiAoaWdub3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gYWNjdXJhY3lcbiAgfVxuXG4gIGNvbnN0IHByb3hpbWl0eSA9IE1hdGguYWJzKGV4cGVjdGVkTG9jYXRpb24gLSBjdXJyZW50TG9jYXRpb24pO1xuXG4gIGlmICghZGlzdGFuY2UpIHtcbiAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3lcbiAgfVxuXG4gIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIGRpc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXNrVG9JbmRpY2VzKFxuICBtYXRjaG1hc2sgPSBbXSxcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aFxuKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCBsZW4gPSBtYXRjaG1hc2subGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaG1hc2tbaV07XG4gICAgaWYgKG1hdGNoICYmIHN0YXJ0ID09PSAtMSkge1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgZW5kID0gaSAtIDE7XG4gICAgICBpZiAoZW5kIC0gc3RhcnQgKyAxID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLy8gKGktMSAtIHN0YXJ0KSArIDEgPT4gaSAtIHN0YXJ0XG4gIGlmIChtYXRjaG1hc2tbaSAtIDFdICYmIGkgLSBzdGFydCA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBpIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNcbn1cblxuLy8gTWFjaGluZSB3b3JkIHNpemVcbmNvbnN0IE1BWF9CSVRTID0gMzI7XG5cbmZ1bmN0aW9uIHNlYXJjaChcbiAgdGV4dCxcbiAgcGF0dGVybixcbiAgcGF0dGVybkFscGhhYmV0LFxuICB7XG4gICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRShNQVhfQklUUykpXG4gIH1cblxuICBjb25zdCBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGg7XG4gIC8vIFNldCBzdGFydGluZyBsb2NhdGlvbiBhdCBiZWdpbm5pbmcgdGV4dCBhbmQgaW5pdGlhbGl6ZSB0aGUgYWxwaGFiZXQuXG4gIGNvbnN0IHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gbG9jYXRpb24gPiB0ZXh0Lmxlbmd0aFxuICBjb25zdCBleHBlY3RlZExvY2F0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jYXRpb24sIHRleHRMZW4pKTtcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgbGV0IGN1cnJlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgbGV0IGJlc3RMb2NhdGlvbiA9IGV4cGVjdGVkTG9jYXRpb247XG5cbiAgLy8gUGVyZm9ybWFuY2U6IG9ubHkgY29tcHV0ZXIgbWF0Y2hlcyB3aGVuIHRoZSBtaW5NYXRjaENoYXJMZW5ndGggPiAxXG4gIC8vIE9SIGlmIGBpbmNsdWRlTWF0Y2hlc2AgaXMgdHJ1ZS5cbiAgY29uc3QgY29tcHV0ZU1hdGNoZXMgPSBtaW5NYXRjaENoYXJMZW5ndGggPiAxIHx8IGluY2x1ZGVNYXRjaGVzO1xuICAvLyBBIG1hc2sgb2YgdGhlIG1hdGNoZXMsIHVzZWQgZm9yIGJ1aWxkaW5nIHRoZSBpbmRpY2VzXG4gIGNvbnN0IG1hdGNoTWFzayA9IGNvbXB1dGVNYXRjaGVzID8gQXJyYXkodGV4dExlbikgOiBbXTtcblxuICBsZXQgaW5kZXg7XG5cbiAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzLCBoZXJlIGZvciBzcGVlZCB1cFxuICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGJlc3RMb2NhdGlvbikpID4gLTEpIHtcbiAgICBsZXQgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBjdXJyZW50TG9jYXRpb246IGluZGV4LFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBNYXRoLm1pbihzY29yZSwgY3VycmVudFRocmVzaG9sZCk7XG4gICAgYmVzdExvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuXG4gICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHBhdHRlcm5MZW4pIHtcbiAgICAgICAgbWF0Y2hNYXNrW2luZGV4ICsgaV0gPSAxO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGJlc3QgbG9jYXRpb25cbiAgYmVzdExvY2F0aW9uID0gLTE7XG5cbiAgbGV0IGxhc3RCaXRBcnIgPSBbXTtcbiAgbGV0IGZpbmFsU2NvcmUgPSAxO1xuICBsZXQgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW47XG5cbiAgY29uc3QgbWFzayA9IDEgPDwgKHBhdHRlcm5MZW4gLSAxKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkgKz0gMSkge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSB0aGUgbWF0Y2ggbG9jYXRpb24gd2UgY2FuIHN0cmF5XG4gICAgLy8gYXQgdGhpcyBlcnJvciBsZXZlbC5cbiAgICBsZXQgYmluTWluID0gMDtcbiAgICBsZXQgYmluTWlkID0gYmluTWF4O1xuXG4gICAgd2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuICAgICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgIGVycm9yczogaSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLFxuICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICBiaW5NaW4gPSBiaW5NaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgICB9XG5cbiAgICAgIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5NYXggPSBiaW5NaWQ7XG5cbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBleHBlY3RlZExvY2F0aW9uIC0gYmluTWlkICsgMSk7XG4gICAgbGV0IGZpbmlzaCA9IGZpbmRBbGxNYXRjaGVzXG4gICAgICA/IHRleHRMZW5cbiAgICAgIDogTWF0aC5taW4oZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgYml0IGFycmF5XG4gICAgbGV0IGJpdEFyciA9IEFycmF5KGZpbmlzaCArIDIpO1xuXG4gICAgYml0QXJyW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xuXG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgaiAtPSAxKSB7XG4gICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gaiAtIDE7XG4gICAgICBsZXQgY2hhck1hdGNoID0gcGF0dGVybkFscGhhYmV0W3RleHQuY2hhckF0KGN1cnJlbnRMb2NhdGlvbildO1xuXG4gICAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgICAgLy8gU3BlZWQgdXA6IHF1aWNrIGJvb2wgdG8gaW50IGNvbnZlcnNpb24gKGkuZSwgYGNoYXJNYXRjaCA/IDEgOiAwYClcbiAgICAgICAgbWF0Y2hNYXNrW2N1cnJlbnRMb2NhdGlvbl0gPSArISFjaGFyTWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoXG4gICAgICBiaXRBcnJbal0gPSAoKGJpdEFycltqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcblxuICAgICAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoXG4gICAgICBpZiAoaSkge1xuICAgICAgICBiaXRBcnJbal0gfD1cbiAgICAgICAgICAoKGxhc3RCaXRBcnJbaiArIDFdIHwgbGFzdEJpdEFycltqXSkgPDwgMSkgfCAxIHwgbGFzdEJpdEFycltqICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChiaXRBcnJbal0gJiBtYXNrKSB7XG4gICAgICAgIGZpbmFsU2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKGZpbmFsU2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIEluZGVlZCBpdCBpc1xuICAgICAgICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBmaW5hbFNjb3JlO1xuICAgICAgICAgIGJlc3RMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGBsb2NgLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgaWYgKGJlc3RMb2NhdGlvbiA8PSBleHBlY3RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBgYmVzdExvY2F0aW9uYCwgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gYGV4cGVjdGVkTG9jYXRpb25gLlxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGV4cGVjdGVkTG9jYXRpb24gLSBiZXN0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGVycm9yczogaSArIDEsXG4gICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHNjb3JlID4gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBsYXN0Qml0QXJyID0gYml0QXJyO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlzTWF0Y2g6IGJlc3RMb2NhdGlvbiA+PSAwLFxuICAgIC8vIENvdW50IGV4YWN0IG1hdGNoZXMgKHRob3NlIHdpdGggYSBzY29yZSBvZiAwKSB0byBiZSBcImFsbW9zdFwiIGV4YWN0XG4gICAgc2NvcmU6IE1hdGgubWF4KDAuMDAxLCBmaW5hbFNjb3JlKVxuICB9O1xuXG4gIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgIGNvbnN0IGluZGljZXMgPSBjb252ZXJ0TWFza1RvSW5kaWNlcyhtYXRjaE1hc2ssIG1pbk1hdGNoQ2hhckxlbmd0aCk7XG4gICAgaWYgKCFpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybikge1xuICBsZXQgbWFzayA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgIG1hc2tbY2hhcl0gPSAobWFza1tjaGFyXSB8fCAwKSB8ICgxIDw8IChsZW4gLSBpIC0gMSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tcbn1cblxuY2xhc3MgQml0YXBTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgIGlmICghdGhpcy5wYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQ2h1bmsgPSAocGF0dGVybiwgc3RhcnRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh7XG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGFscGhhYmV0OiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybiksXG4gICAgICAgIHN0YXJ0SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+IE1BWF9CSVRTKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCByZW1haW5kZXIgPSBsZW4gJSBNQVhfQklUUztcbiAgICAgIGNvbnN0IGVuZCA9IGxlbiAtIHJlbWFpbmRlcjtcblxuICAgICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihpLCBNQVhfQklUUyksIGkpO1xuICAgICAgICBpICs9IE1BWF9CSVRTO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluZGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBsZW4gLSBNQVhfQklUUztcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihzdGFydEluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybiwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHsgaXNDYXNlU2Vuc2l0aXZlLCBpbmNsdWRlTWF0Y2hlcyB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFpc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRXhhY3QgbWF0Y2hcbiAgICBpZiAodGhpcy5wYXR0ZXJuID09PSB0ZXh0KSB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICBzY29yZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgIHJlc3VsdC5pbmRpY2VzID0gW1swLCB0ZXh0Lmxlbmd0aCAtIDFdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgdXNlIEJpdGFwIGFsZ29yaXRobVxuICAgIGNvbnN0IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG5cbiAgICB0aGlzLmNodW5rcy5mb3JFYWNoKCh7IHBhdHRlcm4sIGFscGhhYmV0LCBzdGFydEluZGV4IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaCh0ZXh0LCBwYXR0ZXJuLCBhbHBoYWJldCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gKyBzdGFydEluZGV4LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcblxuICAgICAgaWYgKGlzTWF0Y2ggJiYgaW5kaWNlcykge1xuICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGlzTWF0Y2g6IGhhc01hdGNoZXMsXG4gICAgICBzY29yZTogaGFzTWF0Y2hlcyA/IHRvdGFsU2NvcmUgLyB0aGlzLmNodW5rcy5sZW5ndGggOiAxXG4gICAgfTtcblxuICAgIGlmIChoYXNNYXRjaGVzICYmIGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmNsYXNzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICB9XG4gIHN0YXRpYyBpc011bHRpTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLm11bHRpUmVnZXgpXG4gIH1cbiAgc3RhdGljIGlzU2luZ2xlTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLnNpbmdsZVJlZ2V4KVxuICB9XG4gIHNlYXJjaCgvKnRleHQqLykge31cbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2gocGF0dGVybiwgZXhwKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXR0ZXJuLm1hdGNoKGV4cCk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IG51bGxcbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj1cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL149KC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dCA9PT0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIWZpcmVcblxuY2xhc3MgSW52ZXJzZUV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgY29uc3QgaXNNYXRjaCA9IGluZGV4ID09PSAtMTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiBeZmlsZVxuXG5jbGFzcyBQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3ByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhXmZpcmVcblxuY2xhc3MgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1wcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IC5maWxlJFxuXG5jbGFzcyBTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3N1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogW3RleHQubGVuZ3RoIC0gdGhpcy5wYXR0ZXJuLmxlbmd0aCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIS5maWxlJFxuXG5jbGFzcyBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXN1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1enp5TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gICAgdGhpcy5fYml0YXBTZWFyY2ggPSBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2Z1enp5J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRhcFNlYXJjaC5zZWFyY2hJbih0ZXh0KVxuICB9XG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBJbmNsdWRlTWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW5jbHVkZSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJ1wiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXicoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGxldCBsb2NhdGlvbiA9IDA7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHBhdHRlcm5MZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzXG4gICAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGxvY2F0aW9uKSkgPiAtMSkge1xuICAgICAgbG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG4gICAgICBpbmRpY2VzLnB1c2goW2luZGV4LCBsb2NhdGlvbiAtIDFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGNoID0gISFpbmRpY2VzLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXNcbiAgICB9XG4gIH1cbn1cblxuLy8gXHUyNzU3T3JkZXIgaXMgaW1wb3J0YW50LiBETyBOT1QgQ0hBTkdFLlxuY29uc3Qgc2VhcmNoZXJzID0gW1xuICBFeGFjdE1hdGNoLFxuICBJbmNsdWRlTWF0Y2gsXG4gIFByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCxcbiAgU3VmZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZUV4YWN0TWF0Y2gsXG4gIEZ1enp5TWF0Y2hcbl07XG5cbmNvbnN0IHNlYXJjaGVyc0xlbiA9IHNlYXJjaGVycy5sZW5ndGg7XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGJ5IHNwYWNlcywgYnV0IGtlZXAgYW55dGhpbmcgaW4gcXVvdGVzIHRvZ2V0aGVyXG5jb25zdCBTUEFDRV9SRSA9IC8gKyg/PSg/OlteXFxcIl0qXFxcIlteXFxcIl0qXFxcIikqW15cXFwiXSokKS87XG5jb25zdCBPUl9UT0tFTiA9ICd8JztcblxuLy8gUmV0dXJuIGEgMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5LCBmb3Igc2ltcGxlciBwYXJzaW5nLlxuLy8gRXhhbXBsZTpcbi8vIFwiXmNvcmUgZ28kIHwgcmIkIHwgcHkkIHh5JFwiID0+IFtbXCJeY29yZVwiLCBcImdvJFwiXSwgW1wicmIkXCJdLCBbXCJweSRcIiwgXCJ4eSRcIl1dXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChPUl9UT0tFTikubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHF1ZXJ5ID0gaXRlbVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFNQQUNFX1JFKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiAhIWl0ZW0udHJpbSgpKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBxdWVyeUl0ZW0gPSBxdWVyeVtpXTtcblxuICAgICAgLy8gMS4gSGFuZGxlIG11bHRpcGxlIHF1ZXJ5IG1hdGNoIChpLmUsIG9uY2UgdGhhdCBhcmUgcXVvdGVkLCBsaWtlIGBcImhlbGxvIHdvcmxkXCJgKVxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoIWZvdW5kICYmICsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzTXVsdGlNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBIYW5kbGUgc2luZ2xlIHF1ZXJ5IG1hdGNoZXMgKGkuZSwgb25jZSB0aGF0IGFyZSAqbm90KiBxdW90ZWQpXG4gICAgICBpZHggPSAtMTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc1NpbmdsZU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSlcbn1cblxuLy8gVGhlc2UgZXh0ZW5kZWQgbWF0Y2hlcnMgY2FuIHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGVzLCBhcyBvcHBvc2VkXG4vLyB0byBhIHNpbmdsIG1hdGNoXG5jb25zdCBNdWx0aU1hdGNoU2V0ID0gbmV3IFNldChbRnV6enlNYXRjaC50eXBlLCBJbmNsdWRlTWF0Y2gudHlwZV0pO1xuXG4vKipcbiAqIENvbW1hbmQtbGlrZSBzZWFyY2hpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBHaXZlbiBtdWx0aXBsZSBzZWFyY2ggdGVybXMgZGVsaW1pdGVkIGJ5IHNwYWNlcy5lLmcuIGBeanNjcmlwdCAucHl0aG9uJCBydWJ5ICFqYXZhYCxcbiAqIHNlYXJjaCBpbiBhIGdpdmVuIHRleHQuXG4gKlxuICogU2VhcmNoIHN5bnRheDpcbiAqXG4gKiB8IFRva2VuICAgICAgIHwgTWF0Y2ggdHlwZSAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBqc2NyaXB0YCAgIHwgZnV6enktbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGZ1enp5IG1hdGNoIGBqc2NyaXB0YCAgICAgICB8XG4gKiB8IGA9c2NoZW1lYCAgIHwgZXhhY3QtbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGFyZSBgc2NoZW1lYCAgICAgICAgICAgICAgICB8XG4gKiB8IGAncHl0aG9uYCAgIHwgaW5jbHVkZS1tYXRjaCAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGluY2x1ZGUgYHB5dGhvbmAgICAgICAgICAgICB8XG4gKiB8IGAhcnVieWAgICAgIHwgaW52ZXJzZS1leGFjdC1tYXRjaCAgICAgICAgfCBJdGVtcyB0aGF0IGRvIG5vdCBpbmNsdWRlIGBydWJ5YCAgICAgICB8XG4gKiB8IGBeamF2YWAgICAgIHwgcHJlZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IHN0YXJ0IHdpdGggYGphdmFgICAgICAgICAgICB8XG4gKiB8IGAhXmVhcmxhbmdgIHwgaW52ZXJzZS1wcmVmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGBlYXJsYW5nYCB8XG4gKiB8IGAuanMkYCAgICAgIHwgc3VmZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IGVuZCB3aXRoIGAuanNgICAgICAgICAgICAgICB8XG4gKiB8IGAhLmdvJGAgICAgIHwgaW52ZXJzZS1zdWZmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBgLmdvYCAgICAgICB8XG4gKlxuICogQSBzaW5nbGUgcGlwZSBjaGFyYWN0ZXIgYWN0cyBhcyBhbiBPUiBvcGVyYXRvci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAqIHF1ZXJ5IG1hdGNoZXMgZW50cmllcyB0aGF0IHN0YXJ0IHdpdGggYGNvcmVgIGFuZCBlbmQgd2l0aCBlaXRoZXJgZ29gLCBgcmJgLFxuICogb3JgcHlgLlxuICpcbiAqIGBgYFxuICogXmNvcmUgZ28kIHwgcmIkIHwgcHkkXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvbixcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2VcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIGlnbm9yZUxvY2F0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucXVlcnkgPSBwYXJzZVF1ZXJ5KHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25kaXRpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoXG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuXG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICAgIHNjb3JlOiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmNsdWRlTWF0Y2hlcywgaXNDYXNlU2Vuc2l0aXZlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0ZXh0ID0gaXNDYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBudW1NYXRjaGVzID0gMDtcbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcblxuICAgIC8vIE9Sc1xuICAgIGZvciAobGV0IGkgPSAwLCBxTGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgcUxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzZWFyY2hlcnMgPSBxdWVyeVtpXTtcblxuICAgICAgLy8gUmVzZXQgaW5kaWNlc1xuICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgbnVtTWF0Y2hlcyA9IDA7XG5cbiAgICAgIC8vIEFORHNcbiAgICAgIGZvciAobGV0IGogPSAwLCBwTGVuID0gc2VhcmNoZXJzLmxlbmd0aDsgaiA8IHBMZW47IGogKz0gMSkge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tqXTtcbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBpbmRpY2VzLCBzY29yZSB9ID0gc2VhcmNoZXIuc2VhcmNoKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbnVtTWF0Y2hlcyArPSAxO1xuICAgICAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2VhcmNoZXIuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgICAgIGlmIChNdWx0aU1hdGNoU2V0Lmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcy5wdXNoKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFNjb3JlID0gMDtcbiAgICAgICAgICBudW1NYXRjaGVzID0gMDtcbiAgICAgICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUiBjb25kaXRpb24sIHNvIGlmIFRSVUUsIHJldHVyblxuICAgICAgaWYgKG51bU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICAgIHNjb3JlOiB0b3RhbFNjb3JlIC8gbnVtTWF0Y2hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RoaW5nIHdhcyBtYXRjaGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgc2NvcmU6IDFcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVnaXN0ZXJlZFNlYXJjaGVycyA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3RlciguLi5hcmdzKSB7XG4gIHJlZ2lzdGVyZWRTZWFyY2hlcnMucHVzaCguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnaXN0ZXJlZFNlYXJjaGVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBzZWFyY2hlckNsYXNzID0gcmVnaXN0ZXJlZFNlYXJjaGVyc1tpXTtcbiAgICBpZiAoc2VhcmNoZXJDbGFzcy5jb25kaXRpb24ocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgc2VhcmNoZXJDbGFzcyhwYXR0ZXJuLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwgb3B0aW9ucylcbn1cblxuY29uc3QgTG9naWNhbE9wZXJhdG9yID0ge1xuICBBTkQ6ICckYW5kJyxcbiAgT1I6ICckb3InXG59O1xuXG5jb25zdCBLZXlUeXBlID0ge1xuICBQQVRIOiAnJHBhdGgnLFxuICBQQVRURVJOOiAnJHZhbCdcbn07XG5cbmNvbnN0IGlzRXhwcmVzc2lvbiA9IChxdWVyeSkgPT5cbiAgISEocXVlcnlbTG9naWNhbE9wZXJhdG9yLkFORF0gfHwgcXVlcnlbTG9naWNhbE9wZXJhdG9yLk9SXSk7XG5cbmNvbnN0IGlzUGF0aCA9IChxdWVyeSkgPT4gISFxdWVyeVtLZXlUeXBlLlBBVEhdO1xuXG5jb25zdCBpc0xlYWYgPSAocXVlcnkpID0+XG4gICFpc0FycmF5KHF1ZXJ5KSAmJiBpc09iamVjdChxdWVyeSkgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSk7XG5cbmNvbnN0IGNvbnZlcnRUb0V4cGxpY2l0ID0gKHF1ZXJ5KSA9PiAoe1xuICBbTG9naWNhbE9wZXJhdG9yLkFORF06IE9iamVjdC5rZXlzKHF1ZXJ5KS5tYXAoKGtleSkgPT4gKHtcbiAgICBba2V5XTogcXVlcnlba2V5XVxuICB9KSlcbn0pO1xuXG4vLyBXaGVuIGBhdXRvYCBpcyBgdHJ1ZWAsIHRoZSBwYXJzZSBmdW5jdGlvbiB3aWxsIGluZmVyIGFuZCBpbml0aWFsaXplIGFuZCBhZGRcbi8vIHRoZSBhcHByb3ByaWF0ZSBgU2VhcmNoZXJgIGluc3RhbmNlXG5mdW5jdGlvbiBwYXJzZShxdWVyeSwgb3B0aW9ucywgeyBhdXRvID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IChxdWVyeSkgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnkpO1xuXG4gICAgY29uc3QgaXNRdWVyeVBhdGggPSBpc1BhdGgocXVlcnkpO1xuXG4gICAgaWYgKCFpc1F1ZXJ5UGF0aCAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICAgIHJldHVybiBuZXh0KGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmKHF1ZXJ5KSkge1xuICAgICAgY29uc3Qga2V5ID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVEhdIDoga2V5c1swXTtcblxuICAgICAgY29uc3QgcGF0dGVybiA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRURVJOXSA6IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWShrZXkpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIGtleUlkOiBjcmVhdGVLZXlJZChrZXkpLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBvYmouc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIGxldCBub2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgb3BlcmF0b3I6IGtleXNbMF1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV4dChpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBpZiAoIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICBxdWVyeSA9IGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KHF1ZXJ5KVxufVxuXG4vLyBQcmFjdGljYWwgc2NvcmluZyBmdW5jdGlvblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKFxuICByZXN1bHRzLFxuICB7IGlnbm9yZUZpZWxkTm9ybSA9IENvbmZpZy5pZ25vcmVGaWVsZE5vcm0gfVxuKSB7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAxO1xuXG4gICAgcmVzdWx0Lm1hdGNoZXMuZm9yRWFjaCgoeyBrZXksIG5vcm0sIHNjb3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGtleSA/IGtleS53ZWlnaHQgOiBudWxsO1xuXG4gICAgICB0b3RhbFNjb3JlICo9IE1hdGgucG93KFxuICAgICAgICBzY29yZSA9PT0gMCAmJiB3ZWlnaHQgPyBOdW1iZXIuRVBTSUxPTiA6IHNjb3JlLFxuICAgICAgICAod2VpZ2h0IHx8IDEpICogKGlnbm9yZUZpZWxkTm9ybSA/IDEgOiBub3JtKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5zY29yZSA9IHRvdGFsU2NvcmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXRjaGVzKHJlc3VsdCwgZGF0YSkge1xuICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoZXM7XG4gIGRhdGEubWF0Y2hlcyA9IFtdO1xuXG4gIGlmICghaXNEZWZpbmVkKG1hdGNoZXMpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQobWF0Y2guaW5kaWNlcykgfHwgIW1hdGNoLmluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGljZXMsIHZhbHVlIH0gPSBtYXRjaDtcblxuICAgIGxldCBvYmogPSB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgdmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKG1hdGNoLmtleSkge1xuICAgICAgb2JqLmtleSA9IG1hdGNoLmtleS5zcmM7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmlkeCA+IC0xKSB7XG4gICAgICBvYmoucmVmSW5kZXggPSBtYXRjaC5pZHg7XG4gICAgfVxuXG4gICAgZGF0YS5tYXRjaGVzLnB1c2gob2JqKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNjb3JlKHJlc3VsdCwgZGF0YSkge1xuICBkYXRhLnNjb3JlID0gcmVzdWx0LnNjb3JlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoXG4gIHJlc3VsdHMsXG4gIGRvY3MsXG4gIHtcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpbmNsdWRlU2NvcmUgPSBDb25maWcuaW5jbHVkZVNjb3JlXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IFtdO1xuXG4gIGlmIChpbmNsdWRlTWF0Y2hlcykgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtTWF0Y2hlcyk7XG4gIGlmIChpbmNsdWRlU2NvcmUpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybVNjb3JlKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHsgaWR4IH0gPSByZXN1bHQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaXRlbTogZG9jc1tpZHhdLFxuICAgICAgcmVmSW5kZXg6IGlkeFxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtZXJzLmZvckVhY2goKHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVyKHJlc3VsdCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5jbGFzcyBGdXNlIHtcbiAgY29uc3RydWN0b3IoZG9jcywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uQ29uZmlnLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2ggJiZcbiAgICAgICF0cnVlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFKVxuICAgIH1cblxuICAgIHRoaXMuX2tleVN0b3JlID0gbmV3IEtleVN0b3JlKHRoaXMub3B0aW9ucy5rZXlzKTtcblxuICAgIHRoaXMuc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCk7XG4gIH1cblxuICBzZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KSB7XG4gICAgdGhpcy5fZG9jcyA9IGRvY3M7XG5cbiAgICBpZiAoaW5kZXggJiYgIShpbmRleCBpbnN0YW5jZW9mIEZ1c2VJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihJTkNPUlJFQ1RfSU5ERVhfVFlQRSlcbiAgICB9XG5cbiAgICB0aGlzLl9teUluZGV4ID1cbiAgICAgIGluZGV4IHx8XG4gICAgICBjcmVhdGVJbmRleCh0aGlzLm9wdGlvbnMua2V5cywgdGhpcy5fZG9jcywge1xuICAgICAgICBnZXRGbjogdGhpcy5vcHRpb25zLmdldEZuLFxuICAgICAgICBmaWVsZE5vcm1XZWlnaHQ6IHRoaXMub3B0aW9ucy5maWVsZE5vcm1XZWlnaHRcbiAgICAgIH0pO1xuICB9XG5cbiAgYWRkKGRvYykge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2RvY3MucHVzaChkb2MpO1xuICAgIHRoaXMuX215SW5kZXguYWRkKGRvYyk7XG4gIH1cblxuICByZW1vdmUocHJlZGljYXRlID0gKC8qIGRvYywgaWR4ICovKSA9PiBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9kb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl9kb2NzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShkb2MsIGkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgbGVuIC09IDE7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMuX2RvY3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5fbXlJbmRleC5yZW1vdmVBdChpZHgpO1xuICB9XG5cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX215SW5kZXhcbiAgfVxuXG4gIHNlYXJjaChxdWVyeSwgeyBsaW1pdCA9IC0xIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlLFxuICAgICAgc2hvdWxkU29ydCxcbiAgICAgIHNvcnRGbixcbiAgICAgIGlnbm9yZUZpZWxkTm9ybVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgcmVzdWx0cyA9IGlzU3RyaW5nKHF1ZXJ5KVxuICAgICAgPyBpc1N0cmluZyh0aGlzLl9kb2NzWzBdKVxuICAgICAgICA/IHRoaXMuX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpXG4gICAgICAgIDogdGhpcy5fc2VhcmNoT2JqZWN0TGlzdChxdWVyeSlcbiAgICAgIDogdGhpcy5fc2VhcmNoTG9naWNhbChxdWVyeSk7XG5cbiAgICBjb21wdXRlU2NvcmUocmVzdWx0cywgeyBpZ25vcmVGaWVsZE5vcm0gfSk7XG5cbiAgICBpZiAoc2hvdWxkU29ydCkge1xuICAgICAgcmVzdWx0cy5zb3J0KHNvcnRGbik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKGxpbWl0KSAmJiBsaW1pdCA+IC0xKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdChyZXN1bHRzLCB0aGlzLl9kb2NzLCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZVxuICAgIH0pXG4gIH1cblxuICBfc2VhcmNoU3RyaW5nTGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBzdHJpbmcgaW4gdGhlIGluZGV4XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaXRlbTogdGV4dCxcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgbWF0Y2hlczogW3sgc2NvcmUsIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hMb2dpY2FsKHF1ZXJ5KSB7XG5cbiAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UocXVlcnksIHRoaXMub3B0aW9ucyk7XG5cbiAgICBjb25zdCBldmFsdWF0ZSA9IChub2RlLCBpdGVtLCBpZHgpID0+IHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IGtleUlkLCBzZWFyY2hlciB9ID0gbm9kZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgIGtleTogdGhpcy5fa2V5U3RvcmUuZ2V0KGtleUlkKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5fbXlJbmRleC5nZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSxcbiAgICAgICAgICBzZWFyY2hlclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdGUoY2hpbGQsIGl0ZW0sIGlkeCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBMb2dpY2FsT3BlcmF0b3IuQU5EKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuX215SW5kZXgucmVjb3JkcztcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmIChpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgbGV0IGV4cFJlc3VsdHMgPSBldmFsdWF0ZShleHByZXNzaW9uLCBpdGVtLCBpZHgpO1xuXG4gICAgICAgIGlmIChleHBSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERlZHVwZSB3aGVuIGFkZGluZ1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2lkeF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdID0geyBpZHgsIGl0ZW0sIG1hdGNoZXM6IFtdIH07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0TWFwW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBSZXN1bHRzLmZvckVhY2goKHsgbWF0Y2hlcyB9KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XS5tYXRjaGVzLnB1c2goLi4ubWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoT2JqZWN0TGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgICBtYXRjaGVzLnB1c2goXG4gICAgICAgICAgLi4udGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGl0ZW1ba2V5SW5kZXhdLFxuICAgICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG4gIF9maW5kTWF0Y2hlcyh7IGtleSwgdmFsdWUsIHNlYXJjaGVyIH0pIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBub3JtLFxuICAgICAgICAgICAgaW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2OiB0ZXh0LCBuOiBub3JtIH0gPSB2YWx1ZTtcblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7IHNjb3JlLCBrZXksIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cbn1cblxuRnVzZS52ZXJzaW9uID0gJzcuMC4wJztcbkZ1c2UuY3JlYXRlSW5kZXggPSBjcmVhdGVJbmRleDtcbkZ1c2UucGFyc2VJbmRleCA9IHBhcnNlSW5kZXg7XG5GdXNlLmNvbmZpZyA9IENvbmZpZztcblxue1xuICBGdXNlLnBhcnNlUXVlcnkgPSBwYXJzZTtcbn1cblxue1xuICByZWdpc3RlcihFeHRlbmRlZFNlYXJjaCk7XG59XG5cbmV4cG9ydCB7IEZ1c2UgYXMgZGVmYXVsdCB9O1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFFTzs7O0FDRFAsc0JBQStDO0FBU3hDLElBQU0sbUJBQWlEO0FBQUE7QUFBQSxFQUU1RCxlQUFlO0FBQUEsRUFDZixVQUFVO0FBQUEsRUFDVixlQUFlO0FBQ2pCO0FBRU8sSUFBTSwwQkFBTixjQUFzQyxpQ0FBaUI7QUFBQSxFQUc1RCxZQUFZLEtBQVUsUUFBNEI7QUFDaEQsVUFBTSxLQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFFaEI7QUFBQSxFQUVBLFVBQWdCO0FBQ2QsVUFBTSxFQUFFLFlBQVksSUFBSTtBQUV4QixnQkFBWSxNQUFNO0FBRWxCLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFM0QsUUFBSSx3QkFBUSxXQUFXLEVBQ3BCLFFBQVEsK0JBQStCLEVBQ3ZDLFFBQVEsNElBQTRJLEVBQ3BKO0FBQUEsTUFBUSxDQUFDLFNBQ1IsS0FDRyxlQUFlLGdFQUFnRSxFQUMvRSxTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxDQUFDLFVBQVU7QUFDbkIsYUFBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxhQUFLLE9BQU8sU0FBUyxLQUFLLE9BQU8sUUFBUTtBQUFBLE1BQzNDLENBQUM7QUFB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QUFBQSxNQUNILE9BQU8sWUFBWSxNQUFNLFFBQVEsSUFBSSxhQUFhLEdBQUcsSUFBSSxLQUFLLEdBQUk7QUFBQSxJQUNwRTtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFdBQVc7QUFBQSxFQUlYO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDbkIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUUzRTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ25CLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ25DO0FBQUEsRUFDQSxNQUFNLGVBQWU7QUFDbkIsU0FBSyxJQUFJLFVBQVUsbUJBQW1CLFNBQVM7QUFFL0MsVUFBTSxLQUFLLElBQUksVUFBVSxhQUFhLEtBQUssRUFBRSxhQUFhO0FBQUEsTUFDeEQsTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLElBQ1YsQ0FBQztBQUVELFNBQUssSUFBSSxVQUFVO0FBQUEsTUFDakIsS0FBSyxJQUFJLFVBQVUsZ0JBQWdCLFNBQVMsRUFBRSxDQUFDO0FBQUEsSUFDakQ7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9GOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIm9iaiIsICJwYXRoIiwgIm5vcm0iLCAidmFsdWUiLCAic2NvcmUiLCAicGF0dGVybiIsICJyZXN1bHQiLCAiaXRlbSIsICJzZWFyY2hlcnMiLCAicXVlcnkiXQp9Cg==
